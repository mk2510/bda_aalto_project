---
title: "BDA - Assignment 9"
author: "Anonymous"
header-includes:
   - \usepackage{listings}
output: 
  pdf_document: 
    toc: yes
    toc_depth: 1
urlcolor: blue
---
```{r setup, include=FALSE}
# This chunk sets echo = TRUE as default, that is print all code.
# knitr::opts_chunk$set can be used to set other notebook generation options, too.
# include=FALSE inside curly brackets makes this block not be included in the pdf.
# install.packages("remotes")
# remotes::install_github("avehtari/BDA_course_Aalto",
#         subdir = "rpackage", upgrade="never")
# install.packages("aaltobda")
knitr::opts_chunk$set(echo = TRUE)
library(aaltobda)
library(rstan)
library(loo)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```



# Mathematical Models

## Hierarchical

$$
\begin{aligned}
y_n & \sim Bernoulli(logit^{-1}(x \times \beta_n))\\
\mu_{j} & \sim Normal(0, 100) \\
\sigma_{j} & \sim U(0,\infty) \\
\beta_{i,j} & \sim Normal(\mu_j, \sigma_j) \\
\end{aligned}
$$

We will first try to build a standart stand alone model to see, how t works:
```{r}
standart_model <- "
functions {
  real[] logit_transform(real[] x, real k, real x0) {
    int N = size(x);
    real xtemp[N];
    for (i in 1:N){
      xtemp[i] = 1 / (1 + exp(-k * (x[i] - x0)));
    }
     return xtemp;
  }
}

data {
    int<lower=0> J;
    int<lower=0> N; // number of data points
    real x[N]; // observation year
    vector[N] y; // observation number of drowned
    real xpred;  // prediction year
    real sigma;
}

parameters { 
  real alpha;
  real beta;
  //real<lower=0> sigma; // changed from upper to lower
}

transformed parameters {
  real mu[N] = logit_transform(x,alpha, beta);
}

model {
  alpha ~ normal(0.7476352194,0.0001);
  beta ~ normal(0.5, 0.0001);
  y ~ normal(mu, sigma); // add here a semicolon
}

generated quantities {
  real ypred;
  real t[1];
  t[1] = xpred;
  ypred = normal_rng(logit_transform(t,alpha, beta)[1], sigma);

}

"
```

```{r}
seperated_model <- "
functions {
  real[] logit_transform(real[] x, real k, real x0) {
    int N = size(x);
    real xtemp[N];
    for (i in 1:N){
      xtemp[i] = 1 / (1 + exp(-k * (x[i] - x0)));
    }
     return xtemp;
  }
}

data {
    int<lower=0> J;
    int<lower=1> M;
    int<lower=0> N; // number of data points
    real x[N,M]; // observation year
    vector[N,M] y; // observation number of drowned
    real xpred;  // prediction year
    real sigma;
    vector[M] muAlpha;
    vector[M] muBeta;
}

parameters { 
  real alpha[M];
  real beta[M];
  //real<lower=0> sigma; // changed from upper to lower
}

transformed parameters {
  real mu[N,M]
  for (i in 1:M){
    mu[,i] = logit_transform(x,alpha[i], beta[i]);
  }
  
}

model {
  alpha ~ normal(muAlpha,0.0001);
  beta ~ normal(muBeta, 0.0001);
  y ~ normal(mu, sigma); // add here a semicolon
}

generated quantities {
  real ypred[M];
  real t[1];
  t[1] = xpred;
  for (i in 1:M){
    ypred[i] = normal_rng(logit_transform(t,alpha[i], beta[i])[1], sigma);
  }

}

"
```


```{r}
# setwd("/Users/max/Documents/UniMac/Aalto/BDA/bda_aalto_project/data")
data1 <- read.csv("data/Finland_output.csv")
data2 <- read.csv("data/Germany_output.csv")

```

```{r, results='hide', error=FALSE}
hm <- rstan::stan_model(model_code = standart_model)
stan_data <- list(
    J = 1,
    N = length(data$Y),
    y = data$Y,
    x = data$X,
    xpred = 1.1,
    sigma = 0.0001
  )
model_hirachical <- rstan::sampling(hm, data = stan_data, warmup=4000, iter=4500)
fit_hm <- extract(model_hirachical, permuted = TRUE)
```