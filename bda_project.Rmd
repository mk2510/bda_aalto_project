---
title: "BDA - Assignment 9"
author: "Anonymous"
header-includes:
   - \usepackage{listings}
output: 
  pdf_document: 
    toc: yes
    toc_depth: 1
urlcolor: blue
---
```{r setup, include=FALSE}
# This chunk sets echo = TRUE as default, that is print all code.
# knitr::opts_chunk$set can be used to set other notebook generation options, too.
# include=FALSE inside curly brackets makes this block not be included in the pdf.
install.packages("remotes")
remotes::install_github("avehtari/BDA_course_Aalto",
         subdir = "rpackage", upgrade="never")
install.packages("aaltobda")
knitr::opts_chunk$set(echo = TRUE)
library(aaltobda)
library(rstan)
library(loo)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```



# Mathematical Models

## Hierarchical

$$
\begin{aligned}
y_n & \sim Bernoulli(logit^{-1}(x \times \beta_n))\\
\mu_{j} & \sim Normal(0, 100) \\
\sigma_{j} & \sim U(0,\infty) \\
\beta_{i,j} & \sim Normal(\mu_j, \sigma_j) \\
\end{aligned}
$$

We will first try to build a standart stand alone model to see, how t works:
```{r}
standart_model <- "
functions {
  real[] logit_transform(real[] x, real k, real x0) {
    int N = size(x);
    real xtemp[N];
    for (i in 1:N){
      xtemp[i] = 1 / (1 + exp(-k * (x[i] - x0)));
    }
     return xtemp;
  }
}

data {
    int<lower=0> J;
    int<lower=0> N; // number of data points
    real x[N]; // observation year
    vector[N] y; // observation number of drowned
    real xpred;  // prediction year
    real sigma;
}

parameters { 
  real alpha;
  real beta;
  //real<lower=0> sigma; // changed from upper to lower
}

transformed parameters {
  real mu[N] = logit_transform(x,alpha, beta);
}

model {
  y ~ normal(mu, sigma); // add here a semicolon
}

generated quantities {
  real ypred;
  real t[1];
  t[1] = xpred;
  ypred = normal_rng(logit_transform(t,alpha, beta)[1], sigma);

}

"
```


```{r}
# setwd("/Users/max/Documents/UniMac/Aalto/BDA/bda_aalto_project/data")
data <- read.csv("Nepal_output.csv")
data$X0.0.1
```


```{r, results='hide', error=FALSE}
hierarchical_model = "
data {
  int<lower=1> D;
  int<lower=0> N;
  int<lower=1> L;
  int<lower=0,upper=1> y[N];
  int<lower=1,upper=L> ll[N];
  row_vector[D] x[N];
}
parameters {
  real mu[D];
  real<lower=0> sigma[D];
  vector[D] beta[L];
}
model {
  for (d in 1:D) {
    mu[d] ~ normal(0, 100);
    for (l in 1:L)
      beta[l,d] ~ normal(mu[d], sigma[d]);
  }
  for (n in 1:N)
    y[n] ~ bernoulli(inv_logit(x[n] * beta[ll[n]]));
}
"
```

```{r, results='hide', error=FALSE}
hm <- rstan::stan_model(file = "standart.stan")
stan_data <- list(
    J = 1,
    N = length(data$X0.0.1),
    y = data$X0.0.1,
    x = data$X0.0,
    xpred = 1.1,
    sigma = 0.0001
  )
model_hirachical <- rstan::sampling(hm, data = stan_data)
fit_hm <- extract(model_hirachical, permuted = TRUE)
```