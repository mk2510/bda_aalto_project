---
title: "BDA - Assignment 9"
author: "Anonymous"
header-includes:
   - \usepackage{listings}
output: 
  pdf_document: 
    toc: yes
    toc_depth: 1
urlcolor: blue
---

```{r setup, include=FALSE}
# This chunk sets echo = TRUE as default, that is print all code.
# knitr::opts_chunk$set can be used to set other notebook generation options, too.
# include=FALSE inside curly brackets makes this block not be included in the pdf.
knitr::opts_chunk$set(echo = TRUE)
library(aaltobda)
library(rstan)
library(loo)
options(mc.cores = parallel::detectCores())
rstan_options(auto_write = TRUE)
```



# Mathematical Models

## Hierarchical

$$
\begin{aligned}
y_n & \sim Bernoulli(logit^{-1}(x \times \beta_n))\\
\mu_{j} & \sim Normal(0, 100) \\
\sigma_{j} & \sim U(0,\infty) \\
\beta_{i,j} & \sim Normal(\mu_j, \sigma_j) \\
\end{aligned}
$$

We will first try to build a standart stand alone model to see, how t works:
```{r}
standart_model <- "
data {
    int<lower=0> N; // number of data points
    vector[N] x; // observation year
    vector[N] y; // observation number of drowned
    real xpred;  // prediction year
}

parameters { 
  real alpha;
  real beta;
  real gamma;
  real delta;
  real<lower=0> sigma; // changed from upper to lower
}

functions {
  real logit_transform(real x, real A, real B, real C, real D) {
    return (((A-D)/(1.0+((x/C)**B))) + D)
  }
}

transformed parameters {
  vector[N] mu = logit_transform(x,alpha, beta, gamma, delta)
}

model {
  y ~ normal(mu, sigma); // add here a semicolon
}

generated quantities {
  real ypred = normal_rng(logit_transform(x_pred,alpha, beta, gamma, delta), sigma); // here changed to trainings data instead of mu
}
"
```


```{r, results='hide', error=FALSE}
hierarchical_model = "
data {
  int<lower=1> D;
  int<lower=0> N;
  int<lower=1> L;
  int<lower=0,upper=1> y[N];
  int<lower=1,upper=L> ll[N];
  row_vector[D] x[N];
}
parameters {
  real mu[D];
  real<lower=0> sigma[D];
  vector[D] beta[L];
}
model {
  for (d in 1:D) {
    mu[d] ~ normal(0, 100);
    for (l in 1:L)
      beta[l,d] ~ normal(mu[d], sigma[d]);
  }
  for (n in 1:N)
    y[n] ~ bernoulli(inv_logit(x[n] * beta[ll[n]]));
}
"
```